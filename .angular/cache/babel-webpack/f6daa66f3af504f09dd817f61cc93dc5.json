{"ast":null,"code":"import _classCallCheck from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { InjectionToken, Injectable, ɵɵdefineInjectable, EventEmitter, Directive, Optional, Inject, ElementRef, NgZone, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport Sortable from 'sortablejs';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/globals.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nvar GLOBALS = new InjectionToken('Global config for sortablejs');\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs-binding.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar SortablejsBinding = /*#__PURE__*/function () {\n  /**\n   * @param {?} target\n   */\n  function SortablejsBinding(target) {\n    _classCallCheck(this, SortablejsBinding);\n\n    this.target = target;\n  }\n  /**\n   * @param {?} index\n   * @param {?} item\n   * @return {?}\n   */\n\n\n  _createClass(SortablejsBinding, [{\n    key: \"insert\",\n    value: function insert(index, item) {\n      if (this.isFormArray) {\n        this.target.insert(index, item);\n      } else {\n        this.target.splice(index, 0, item);\n      }\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.isFormArray ? this.target.at(index) : this.target[index];\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(index) {\n      /** @type {?} */\n      var item;\n\n      if (this.isFormArray) {\n        item = this.target.at(index);\n        this.target.removeAt(index);\n      } else {\n        item = this.target.splice(index, 1)[0];\n      }\n\n      return item;\n    } // we need this to identify that the target is a FormArray\n    // we don't want to have a dependency on @angular/forms just for that\n\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"isFormArray\",\n    get: function get() {\n      // just checking for random FormArray methods not available on a standard array\n      return !!this.target.at && !!this.target.insert && !!this.target.reset;\n    }\n  }]);\n\n  return SortablejsBinding;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  SortablejsBinding.prototype.target;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs-bindings.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar SortablejsBindings = /*#__PURE__*/function () {\n  /**\n   * @param {?} bindingTargets\n   */\n  function SortablejsBindings(bindingTargets) {\n    _classCallCheck(this, SortablejsBindings);\n\n    this.bindings = bindingTargets.map(\n    /**\n    * @param {?} target\n    * @return {?}\n    */\n    function (target) {\n      return new SortablejsBinding(target);\n    });\n  }\n  /**\n   * @param {?} index\n   * @param {?} items\n   * @return {?}\n   */\n\n\n  _createClass(SortablejsBindings, [{\n    key: \"injectIntoEvery\",\n    value: function injectIntoEvery(index, items) {\n      this.bindings.forEach(\n      /**\n      * @param {?} b\n      * @param {?} i\n      * @return {?}\n      */\n      function (b, i) {\n        return b.insert(index, items[i]);\n      });\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"getFromEvery\",\n    value: function getFromEvery(index) {\n      return this.bindings.map(\n      /**\n      * @param {?} b\n      * @return {?}\n      */\n      function (b) {\n        return b.get(index);\n      });\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"extractFromEvery\",\n    value: function extractFromEvery(index) {\n      return this.bindings.map(\n      /**\n      * @param {?} b\n      * @return {?}\n      */\n      function (b) {\n        return b.remove(index);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"provided\",\n    get: function get() {\n      return !!this.bindings.length;\n    }\n  }]);\n\n  return SortablejsBindings;\n}();\n\nif (false) {\n  /** @type {?} */\n  SortablejsBindings.prototype.bindings;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar SortablejsService = /*#__PURE__*/(function () {\n  var SortablejsService = function SortablejsService() {\n    _classCallCheck(this, SortablejsService);\n  };\n\n  SortablejsService.ɵfac = function SortablejsService_Factory(t) {\n    return new (t || SortablejsService)();\n  };\n  /** @nocollapse */\n\n\n  SortablejsService.ɵprov = ɵɵdefineInjectable({\n    factory: function SortablejsService_Factory() {\n      return new SortablejsService();\n    },\n    token: SortablejsService,\n    providedIn: \"root\"\n  });\n  return SortablejsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  SortablejsService.prototype.transfer;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar getIndexesFromEvent =\n/**\n* @param {?} event\n* @return {?}\n*/\nfunction getIndexesFromEvent(event) {\n  if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n    return {\n      new: event.newDraggableIndex,\n      old: event.oldDraggableIndex\n    };\n  } else {\n    return {\n      new: event.newIndex,\n      old: event.oldIndex\n    };\n  }\n};\n\nvar ɵ0 = getIndexesFromEvent;\nvar SortablejsDirective = /*#__PURE__*/(function () {\n  var SortablejsDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} globalConfig\n     * @param {?} service\n     * @param {?} element\n     * @param {?} zone\n     * @param {?} renderer\n     */\n    function SortablejsDirective(globalConfig, service, element, zone, renderer) {\n      _classCallCheck(this, SortablejsDirective);\n\n      this.globalConfig = globalConfig;\n      this.service = service;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.sortablejsInit = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(SortablejsDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (Sortable && Sortable.create) {\n          // Sortable does not exist in angular universal (SSR)\n          this.create();\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var _this = this;\n\n        /** @type {?} */\n        var optionsChange = changes.sortablejsOptions;\n\n        if (optionsChange && !optionsChange.isFirstChange()) {\n          /** @type {?} */\n          var previousOptions = optionsChange.previousValue;\n          /** @type {?} */\n\n          var currentOptions = optionsChange.currentValue;\n          Object.keys(currentOptions).forEach(\n          /**\n          * @param {?} optionName\n          * @return {?}\n          */\n          function (optionName) {\n            if (currentOptions[optionName] !== previousOptions[optionName]) {\n              // use low-level option setter\n              _this.sortableInstance.option(optionName, _this.options[optionName]);\n            }\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.sortableInstance) {\n          this.sortableInstance.destroy();\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"create\",\n      value: function create() {\n        var _this2 = this;\n\n        /** @type {?} */\n        var container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2.sortableInstance = Sortable.create(container, _this2.options);\n\n          _this2.sortablejsInit.emit(_this2.sortableInstance);\n        }, 0);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getBindings\",\n      value: function getBindings() {\n        if (!this.sortablejs) {\n          return new SortablejsBindings([]);\n        } else if (this.sortablejs instanceof SortablejsBindings) {\n          return this.sortablejs;\n        } else {\n          return new SortablejsBindings([this.sortablejs]);\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"options\",\n      get: function get() {\n        return Object.assign(Object.assign({}, this.optionsWithoutEvents), this.overridenOptions);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"optionsWithoutEvents\",\n      get: function get() {\n        return Object.assign(Object.assign({}, this.globalConfig || {}), this.sortablejsOptions || {});\n      }\n      /**\n       * @private\n       * @param {?} eventName\n       * @param {...?} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"proxyEvent\",\n      value: function proxyEvent(eventName) {\n        var _this3 = this;\n\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          if (_this3.optionsWithoutEvents && _this3.optionsWithoutEvents[eventName]) {\n            var _this3$optionsWithout;\n\n            (_this3$optionsWithout = _this3.optionsWithoutEvents)[eventName].apply(_this3$optionsWithout, params);\n          }\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"isCloning\",\n      get: function get() {\n        return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n      }\n      /**\n       * @private\n       * @template T\n       * @param {?} item\n       * @return {?}\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone(item) {\n        // by default pass the item through, no cloning performed\n        return (this.sortablejsCloneFunction ||\n        /**\n        * @param {?} subitem\n        * @return {?}\n        */\n        function (subitem) {\n          return subitem;\n        })(item);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"overridenOptions\",\n      get: function get() {\n        var _this4 = this;\n\n        // always intercept standard events but act only in case items are set (bindingEnabled)\n        // allows to forget about tracking this.items changes\n        return {\n          onAdd:\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function onAdd(event) {\n            _this4.service.transfer =\n            /**\n            * @param {?} items\n            * @return {?}\n            */\n            function (items) {\n              _this4.getBindings().injectIntoEvery(event.newIndex, items);\n\n              _this4.proxyEvent('onAdd', event);\n            };\n\n            _this4.proxyEvent('onAddOriginal', event);\n          },\n          onRemove:\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function onRemove(event) {\n            /** @type {?} */\n            var bindings = _this4.getBindings();\n\n            if (bindings.provided) {\n              if (_this4.isCloning) {\n                _this4.service.transfer(bindings.getFromEvery(event.oldIndex).map(\n                /**\n                * @param {?} item\n                * @return {?}\n                */\n                function (item) {\n                  return _this4.clone(item);\n                })); // great thanks to https://github.com/tauu\n                // event.item is the original item from the source list which is moved to the target list\n                // event.clone is a clone of the original item and will be added to source list\n                // If bindings are provided, adding the item dom element to the target list causes artifacts\n                // as it interferes with the rendering performed by the angular template.\n                // Therefore we remove it immediately and also move the original item back to the source list.\n                // (event handler may be attached to the original item and not its clone, therefore keeping\n                // the original dom node, circumvents side effects )\n\n\n                _this4.renderer.removeChild(event.item.parentNode, event.item);\n\n                _this4.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n\n                _this4.renderer.removeChild(event.clone.parentNode, event.clone);\n              } else {\n                _this4.service.transfer(bindings.extractFromEvery(event.oldIndex));\n              }\n\n              _this4.service.transfer = null;\n            }\n\n            _this4.proxyEvent('onRemove', event);\n          },\n          onUpdate:\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function onUpdate(event) {\n            /** @type {?} */\n            var bindings = _this4.getBindings();\n            /** @type {?} */\n\n\n            var indexes = getIndexesFromEvent(event);\n            bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n\n            _this4.proxyEvent('onUpdate', event);\n          }\n        };\n      }\n    }]);\n\n    return SortablejsDirective;\n  }();\n\n  SortablejsDirective.ɵfac = function SortablejsDirective_Factory(t) {\n    return new (t || SortablejsDirective)(ɵngcc0.ɵɵdirectiveInject(GLOBALS, 8), ɵngcc0.ɵɵdirectiveInject(SortablejsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  SortablejsDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SortablejsDirective,\n    selectors: [[\"\", \"sortablejs\", \"\"]],\n    inputs: {\n      sortablejs: \"sortablejs\",\n      sortablejsContainer: \"sortablejsContainer\",\n      sortablejsOptions: \"sortablejsOptions\",\n      sortablejsCloneFunction: \"sortablejsCloneFunction\"\n    },\n    outputs: {\n      sortablejsInit: \"sortablejsInit\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return SortablejsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  SortablejsDirective.prototype.sortablejs;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsContainer;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsOptions;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsCloneFunction;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.sortableInstance;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsInit;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.globalConfig;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.service;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.renderer;\n}\n/**\n * @record\n */\n\n\nfunction SortableEvent() {}\n\nif (false) {\n  /** @type {?} */\n  SortableEvent.prototype.oldIndex;\n  /** @type {?} */\n\n  SortableEvent.prototype.newIndex;\n  /** @type {?|undefined} */\n\n  SortableEvent.prototype.oldDraggableIndex;\n  /** @type {?|undefined} */\n\n  SortableEvent.prototype.newDraggableIndex;\n  /** @type {?} */\n\n  SortableEvent.prototype.item;\n  /** @type {?} */\n\n  SortableEvent.prototype.clone;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar SortablejsModule = /*#__PURE__*/(function () {\n  var SortablejsModule = /*#__PURE__*/function () {\n    function SortablejsModule() {\n      _classCallCheck(this, SortablejsModule);\n    }\n\n    _createClass(SortablejsModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @param {?} globalOptions\n       * @return {?}\n       */\n      function forRoot(globalOptions) {\n        return {\n          ngModule: SortablejsModule,\n          providers: [{\n            provide: GLOBALS,\n            useValue: globalOptions\n          }]\n        };\n      }\n    }]);\n\n    return SortablejsModule;\n  }();\n\n  SortablejsModule.ɵfac = function SortablejsModule_Factory(t) {\n    return new (t || SortablejsModule)();\n  };\n\n  SortablejsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SortablejsModule\n  });\n  SortablejsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return SortablejsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SortablejsModule, {\n    declarations: [SortablejsDirective],\n    exports: [SortablejsDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-sortablejs.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { SortablejsDirective, SortablejsModule, GLOBALS as ɵa, SortablejsService as ɵb }; //# sourceMappingURL=ngx-sortablejs.js.map","map":null,"metadata":{},"sourceType":"module"}