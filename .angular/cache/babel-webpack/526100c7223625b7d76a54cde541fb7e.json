{"ast":null,"code":"'use strict';\n\nvar emitter = require('contra/emitter');\n\nvar crossvent = require('crossvent');\n\nvar classes = require('./classes');\n\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula(initialContainers, options) {\n  var len = arguments.length;\n\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n\n  var _mirror; // mirror image\n\n\n  var _source; // source container\n\n\n  var _item; // item being dragged\n\n\n  var _offsetX; // reference x\n\n\n  var _offsetY; // reference y\n\n\n  var _moveX; // reference move x\n\n\n  var _moveY; // reference move y\n\n\n  var _initialSibling; // reference sibling when grabbed\n\n\n  var _currentSibling; // reference sibling now\n\n\n  var _copy; // item used for copying\n\n\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n\n\n  var _lastDropTarget = null; // last container item was over\n\n  var _grabbed; // holds mousedown context until first mousemove\n\n\n  var o = options || {};\n\n  if (o.moves === void 0) {\n    o.moves = always;\n  }\n\n  if (o.accepts === void 0) {\n    o.accepts = always;\n  }\n\n  if (o.invalid === void 0) {\n    o.invalid = invalidTarget;\n  }\n\n  if (o.containers === void 0) {\n    o.containers = initialContainers || [];\n  }\n\n  if (o.isContainer === void 0) {\n    o.isContainer = never;\n  }\n\n  if (o.copy === void 0) {\n    o.copy = false;\n  }\n\n  if (o.copySortSource === void 0) {\n    o.copySortSource = false;\n  }\n\n  if (o.revertOnSpill === void 0) {\n    o.revertOnSpill = false;\n  }\n\n  if (o.removeOnSpill === void 0) {\n    o.removeOnSpill = false;\n  }\n\n  if (o.direction === void 0) {\n    o.direction = 'vertical';\n  }\n\n  if (o.ignoreInputTextSelection === void 0) {\n    o.ignoreInputTextSelection = true;\n  }\n\n  if (o.mirrorContainer === void 0) {\n    o.mirrorContainer = doc.body;\n  }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n  return drake;\n\n  function isContainer(el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements(remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements(remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy() {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed(e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab(e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n\n    var item = e.target;\n    var context = canStart(item);\n\n    if (!context) {\n      return;\n    }\n\n    _grabbed = context;\n    eventualMovements();\n\n    if (e.type === 'mousedown') {\n      if (isInput(item)) {\n        // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved(e) {\n    if (!_grabbed) {\n      return;\n    }\n\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    } // truthy check fixes #239, equality fixes #207\n\n\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart(item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n\n    var handle = item;\n\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n\n      item = getParent(item); // drag target should be a top element\n\n      if (!item) {\n        return;\n      }\n    }\n\n    var source = getParent(item);\n\n    if (!source) {\n      return;\n    }\n\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove(item) {\n    return !!canStart(item);\n  }\n\n  function manualStart(item) {\n    var context = canStart(item);\n\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start(context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget() {\n    return false;\n  }\n\n  function end() {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab() {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release(e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n\n    if (dropTarget && (_copy && o.copySortSource || !_copy || dropTarget !== _source)) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop(item, target) {\n    var parent = getParent(item);\n\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n\n    cleanup();\n  }\n\n  function remove() {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var item = _copy || _item;\n    var parent = getParent(item);\n\n    if (parent) {\n      parent.removeChild(item);\n    }\n\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel(revert) {\n    if (!drake.dragging) {\n      return;\n    }\n\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n\n    cleanup();\n  }\n\n  function cleanup() {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n\n    drake.dragging = false;\n\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement(target, s) {\n    var sibling;\n\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget(elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n\n    return target;\n\n    function accepted() {\n      var droppable = isContainer(target);\n\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag(e) {\n    if (!_mirror) {\n      return;\n    }\n\n    e.preventDefault();\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n\n    var parent = getParent(item);\n\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n\n      return;\n    }\n\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n\n      return;\n    }\n\n    if (reference === null && changed || reference !== item && reference !== nextEl(item)) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n\n    function moved(type) {\n      drake.emit(type, item, _lastDropTarget, _source);\n    }\n\n    function over() {\n      if (changed) {\n        moved('over');\n      }\n    }\n\n    function out() {\n      if (_lastDropTarget) {\n        moved('out');\n      }\n    }\n  }\n\n  function spillOver(el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut(el) {\n    if (drake.dragging) {\n      classes.add(el, 'gu-hide');\n    }\n  }\n\n  function renderMirrorImage() {\n    if (_mirror) {\n      return;\n    }\n\n    var rect = _item.getBoundingClientRect();\n\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage() {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild(dropTarget, target) {\n    var immediate = target;\n\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n\n    if (immediate === documentElement) {\n      return null;\n    }\n\n    return immediate;\n  }\n\n  function getReference(dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside() {\n      // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n\n        if (horizontal && rect.left + rect.width / 2 > x) {\n          return el;\n        }\n\n        if (!horizontal && rect.top + rect.height / 2 > y) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n    function inside() {\n      // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy(item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy(el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton(e) {\n  if (e.touches !== void 0) {\n    return e.touches.length;\n  }\n\n  if (e.which !== void 0 && e.which !== 0) {\n    return e.which;\n  } // see https://github.com/bevacqua/dragula/issues/261\n\n\n  if (e.buttons !== void 0) {\n    return e.buttons;\n  }\n\n  var button = e.button;\n\n  if (button !== void 0) {\n    // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n}\n\nfunction getOffset(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint(point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\n\nfunction never() {\n  return false;\n}\n\nfunction always() {\n  return true;\n}\n\nfunction getRectWidth(rect) {\n  return rect.width || rect.right - rect.left;\n}\n\nfunction getRectHeight(rect) {\n  return rect.height || rect.bottom - rect.top;\n}\n\nfunction getParent(el) {\n  return el.parentNode === doc ? null : el.parentNode;\n}\n\nfunction isInput(el) {\n  return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el);\n}\n\nfunction isEditable(el) {\n  if (!el) {\n    return false;\n  } // no parents were editable\n\n\n  if (el.contentEditable === 'false') {\n    return false;\n  } // stop the lookup\n\n\n  if (el.contentEditable === 'true') {\n    return true;\n  } // found a contentEditable element in the chain\n\n\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl(el) {\n  return el.nextElementSibling || manually();\n\n  function manually() {\n    var sibling = el;\n\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n\n    return sibling;\n  }\n}\n\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n\n  return e;\n}\n\nfunction getCoord(coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX',\n    // IE8\n    pageY: 'clientY' // IE8\n\n  };\n\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n\n  return host[coord];\n}\n\nmodule.exports = dragula;","map":{"version":3,"sources":["C:/dev/saltiest/node_modules/dragula/dragula.js"],"names":["emitter","require","crossvent","classes","doc","document","documentElement","dragula","initialContainers","options","len","arguments","length","Array","isArray","_mirror","_source","_item","_offsetX","_offsetY","_moveX","_moveY","_initialSibling","_currentSibling","_copy","_renderTimer","_lastDropTarget","_grabbed","o","moves","always","accepts","invalid","invalidTarget","containers","isContainer","never","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","body","drake","start","manualStart","end","cancel","remove","destroy","canMove","dragging","on","spillOver","spillOut","events","el","indexOf","op","touchy","grab","release","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","e","preventDefault","clientX","clientY","ignore","whichMouseButton","metaKey","ctrlKey","item","target","context","canStart","type","isInput","focus","getCoord","elementBehindCursor","elementFromPoint","grabbed","offset","getOffset","left","top","add","renderMirrorImage","drag","handle","getParent","source","movable","nextEl","isCopy","cloneNode","emit","drop","ungrab","getElementBehindPoint","dropTarget","findDropTarget","parent","removeChild","isInitialPlacement","cleanup","revert","reverts","initial","insertBefore","removeMirrorImage","rm","clearTimeout","s","sibling","accepted","droppable","immediate","getImmediateChild","reference","getReference","x","y","style","changed","out","over","moved","rect","getBoundingClientRect","width","getRectWidth","height","getRectHeight","appendChild","horizontal","inside","outside","children","i","resolve","after","container","fn","touch","mouseup","mousedown","mousemove","pointers","microsoft","global","navigator","pointerEnabled","msPointerEnabled","touches","which","buttons","button","getScroll","scrollProp","offsetProp","clientHeight","point","p","state","className","right","bottom","parentNode","tagName","isEditable","contentEditable","nextElementSibling","manually","nextSibling","nodeType","getEventHost","targetTouches","changedTouches","coord","host","missMap","pageX","pageY","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar emitter = require('contra/emitter');\nvar crossvent = require('crossvent');\nvar classes = require('./classes');\nvar doc = document;\nvar documentElement = doc.documentElement;\n\nfunction dragula (initialContainers, options) {\n  var len = arguments.length;\n  if (len === 1 && Array.isArray(initialContainers) === false) {\n    options = initialContainers;\n    initialContainers = [];\n  }\n  var _mirror; // mirror image\n  var _source; // source container\n  var _item; // item being dragged\n  var _offsetX; // reference x\n  var _offsetY; // reference y\n  var _moveX; // reference move x\n  var _moveY; // reference move y\n  var _initialSibling; // reference sibling when grabbed\n  var _currentSibling; // reference sibling now\n  var _copy; // item used for copying\n  var _renderTimer; // timer for setTimeout renderMirrorImage\n  var _lastDropTarget = null; // last container item was over\n  var _grabbed; // holds mousedown context until first mousemove\n\n  var o = options || {};\n  if (o.moves === void 0) { o.moves = always; }\n  if (o.accepts === void 0) { o.accepts = always; }\n  if (o.invalid === void 0) { o.invalid = invalidTarget; }\n  if (o.containers === void 0) { o.containers = initialContainers || []; }\n  if (o.isContainer === void 0) { o.isContainer = never; }\n  if (o.copy === void 0) { o.copy = false; }\n  if (o.copySortSource === void 0) { o.copySortSource = false; }\n  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }\n  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }\n  if (o.direction === void 0) { o.direction = 'vertical'; }\n  if (o.ignoreInputTextSelection === void 0) { o.ignoreInputTextSelection = true; }\n  if (o.mirrorContainer === void 0) { o.mirrorContainer = doc.body; }\n\n  var drake = emitter({\n    containers: o.containers,\n    start: manualStart,\n    end: end,\n    cancel: cancel,\n    remove: remove,\n    destroy: destroy,\n    canMove: canMove,\n    dragging: false\n  });\n\n  if (o.removeOnSpill === true) {\n    drake.on('over', spillOver).on('out', spillOut);\n  }\n\n  events();\n\n  return drake;\n\n  function isContainer (el) {\n    return drake.containers.indexOf(el) !== -1 || o.isContainer(el);\n  }\n\n  function events (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousedown', grab);\n    touchy(documentElement, op, 'mouseup', release);\n  }\n\n  function eventualMovements (remove) {\n    var op = remove ? 'remove' : 'add';\n    touchy(documentElement, op, 'mousemove', startBecauseMouseMoved);\n  }\n\n  function movements (remove) {\n    var op = remove ? 'remove' : 'add';\n    crossvent[op](documentElement, 'selectstart', preventGrabbed); // IE8\n    crossvent[op](documentElement, 'click', preventGrabbed);\n  }\n\n  function destroy () {\n    events(true);\n    release({});\n  }\n\n  function preventGrabbed (e) {\n    if (_grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  function grab (e) {\n    _moveX = e.clientX;\n    _moveY = e.clientY;\n\n    var ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    var item = e.target;\n    var context = canStart(item);\n    if (!context) {\n      return;\n    }\n    _grabbed = context;\n    eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  function startBecauseMouseMoved (e) {\n    if (!_grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      release({});\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n    // truthy check fixes #239, equality fixes #207\n    if (e.clientX !== void 0 && e.clientX === _moveX && e.clientY !== void 0 && e.clientY === _moveY) {\n      return;\n    }\n    if (o.ignoreInputTextSelection) {\n      var clientX = getCoord('clientX', e);\n      var clientY = getCoord('clientY', e);\n      var elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    var grabbed = _grabbed; // call to end() unsets _grabbed\n    eventualMovements(true);\n    movements();\n    end();\n    start(grabbed);\n\n    var offset = getOffset(_item);\n    _offsetX = getCoord('pageX', e) - offset.left;\n    _offsetY = getCoord('pageY', e) - offset.top;\n\n    classes.add(_copy || _item, 'gu-transit');\n    renderMirrorImage();\n    drag(e);\n  }\n\n  function canStart (item) {\n    if (drake.dragging && _mirror) {\n      return;\n    }\n    if (isContainer(item)) {\n      return; // don't drag container itself\n    }\n    var handle = item;\n    while (getParent(item) && isContainer(getParent(item)) === false) {\n      if (o.invalid(item, handle)) {\n        return;\n      }\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    var source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (o.invalid(item, handle)) {\n      return;\n    }\n\n    var movable = o.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    return {\n      item: item,\n      source: source\n    };\n  }\n\n  function canMove (item) {\n    return !!canStart(item);\n  }\n\n  function manualStart (item) {\n    var context = canStart(item);\n    if (context) {\n      start(context);\n    }\n  }\n\n  function start (context) {\n    if (isCopy(context.item, context.source)) {\n      _copy = context.item.cloneNode(true);\n      drake.emit('cloned', _copy, context.item, 'copy');\n    }\n\n    _source = context.source;\n    _item = context.item;\n    _initialSibling = _currentSibling = nextEl(context.item);\n\n    drake.dragging = true;\n    drake.emit('drag', _item, _source);\n  }\n\n  function invalidTarget () {\n    return false;\n  }\n\n  function end () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    drop(item, getParent(item));\n  }\n\n  function ungrab () {\n    _grabbed = false;\n    eventualMovements(true);\n    movements(true);\n  }\n\n  function release (e) {\n    ungrab();\n\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    if (dropTarget && ((_copy && o.copySortSource) || (!_copy || dropTarget !== _source))) {\n      drop(item, dropTarget);\n    } else if (o.removeOnSpill) {\n      remove();\n    } else {\n      cancel();\n    }\n  }\n\n  function drop (item, target) {\n    var parent = getParent(item);\n    if (_copy && o.copySortSource && target === _source) {\n      parent.removeChild(_item);\n    }\n    if (isInitialPlacement(target)) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, target, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function remove () {\n    if (!drake.dragging) {\n      return;\n    }\n    var item = _copy || _item;\n    var parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    drake.emit(_copy ? 'cancel' : 'remove', item, parent, _source);\n    cleanup();\n  }\n\n  function cancel (revert) {\n    if (!drake.dragging) {\n      return;\n    }\n    var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n    var item = _copy || _item;\n    var parent = getParent(item);\n    var initial = isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (_copy) {\n        if (parent) {\n          parent.removeChild(_copy);\n        }\n      } else {\n        _source.insertBefore(item, _initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      drake.emit('cancel', item, _source, _source);\n    } else {\n      drake.emit('drop', item, parent, _source, _currentSibling);\n    }\n    cleanup();\n  }\n\n  function cleanup () {\n    var item = _copy || _item;\n    ungrab();\n    removeMirrorImage();\n    if (item) {\n      classes.rm(item, 'gu-transit');\n    }\n    if (_renderTimer) {\n      clearTimeout(_renderTimer);\n    }\n    drake.dragging = false;\n    if (_lastDropTarget) {\n      drake.emit('out', item, _lastDropTarget, _source);\n    }\n    drake.emit('dragend', item);\n    _source = _item = _copy = _initialSibling = _currentSibling = _renderTimer = _lastDropTarget = null;\n  }\n\n  function isInitialPlacement (target, s) {\n    var sibling;\n    if (s !== void 0) {\n      sibling = s;\n    } else if (_mirror) {\n      sibling = _currentSibling;\n    } else {\n      sibling = nextEl(_copy || _item);\n    }\n    return target === _source && sibling === _initialSibling;\n  }\n\n  function findDropTarget (elementBehindCursor, clientX, clientY) {\n    var target = elementBehindCursor;\n    while (target && !accepted()) {\n      target = getParent(target);\n    }\n    return target;\n\n    function accepted () {\n      var droppable = isContainer(target);\n      if (droppable === false) {\n        return false;\n      }\n\n      var immediate = getImmediateChild(target, elementBehindCursor);\n      var reference = getReference(target, immediate, clientX, clientY);\n      var initial = isInitialPlacement(target, reference);\n      if (initial) {\n        return true; // should always be able to drop it right back where it was\n      }\n      return o.accepts(_item, target, _source, reference);\n    }\n  }\n\n  function drag (e) {\n    if (!_mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    var clientX = getCoord('clientX', e);\n    var clientY = getCoord('clientY', e);\n    var x = clientX - _offsetX;\n    var y = clientY - _offsetY;\n\n    _mirror.style.left = x + 'px';\n    _mirror.style.top = y + 'px';\n\n    var item = _copy || _item;\n    var elementBehindCursor = getElementBehindPoint(_mirror, clientX, clientY);\n    var dropTarget = findDropTarget(elementBehindCursor, clientX, clientY);\n    var changed = dropTarget !== null && dropTarget !== _lastDropTarget;\n    if (changed || dropTarget === null) {\n      out();\n      _lastDropTarget = dropTarget;\n      over();\n    }\n    var parent = getParent(item);\n    if (dropTarget === _source && _copy && !o.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    var reference;\n    var immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = getReference(dropTarget, immediate, clientX, clientY);\n    } else if (o.revertOnSpill === true && !_copy) {\n      reference = _initialSibling;\n      dropTarget = _source;\n    } else {\n      if (_copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed) ||\n      reference !== item &&\n      reference !== nextEl(item)\n    ) {\n      _currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      drake.emit('shadow', item, dropTarget, _source);\n    }\n    function moved (type) { drake.emit(type, item, _lastDropTarget, _source); }\n    function over () { if (changed) { moved('over'); } }\n    function out () { if (_lastDropTarget) { moved('out'); } }\n  }\n\n  function spillOver (el) {\n    classes.rm(el, 'gu-hide');\n  }\n\n  function spillOut (el) {\n    if (drake.dragging) { classes.add(el, 'gu-hide'); }\n  }\n\n  function renderMirrorImage () {\n    if (_mirror) {\n      return;\n    }\n    var rect = _item.getBoundingClientRect();\n    _mirror = _item.cloneNode(true);\n    _mirror.style.width = getRectWidth(rect) + 'px';\n    _mirror.style.height = getRectHeight(rect) + 'px';\n    classes.rm(_mirror, 'gu-transit');\n    classes.add(_mirror, 'gu-mirror');\n    o.mirrorContainer.appendChild(_mirror);\n    touchy(documentElement, 'add', 'mousemove', drag);\n    classes.add(o.mirrorContainer, 'gu-unselectable');\n    drake.emit('cloned', _mirror, _item, 'mirror');\n  }\n\n  function removeMirrorImage () {\n    if (_mirror) {\n      classes.rm(o.mirrorContainer, 'gu-unselectable');\n      touchy(documentElement, 'remove', 'mousemove', drag);\n      getParent(_mirror).removeChild(_mirror);\n      _mirror = null;\n    }\n  }\n\n  function getImmediateChild (dropTarget, target) {\n    var immediate = target;\n    while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n      immediate = getParent(immediate);\n    }\n    if (immediate === documentElement) {\n      return null;\n    }\n    return immediate;\n  }\n\n  function getReference (dropTarget, target, x, y) {\n    var horizontal = o.direction === 'horizontal';\n    var reference = target !== dropTarget ? inside() : outside();\n    return reference;\n\n    function outside () { // slower, but able to figure out any position\n      var len = dropTarget.children.length;\n      var i;\n      var el;\n      var rect;\n      for (i = 0; i < len; i++) {\n        el = dropTarget.children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside () { // faster, but only available if dropped inside a child element\n      var rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    function resolve (after) {\n      return after ? nextEl(target) : target;\n    }\n  }\n\n  function isCopy (item, container) {\n    return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n  }\n}\n\nfunction touchy (el, op, type, fn) {\n  var touch = {\n    mouseup: 'touchend',\n    mousedown: 'touchstart',\n    mousemove: 'touchmove'\n  };\n  var pointers = {\n    mouseup: 'pointerup',\n    mousedown: 'pointerdown',\n    mousemove: 'pointermove'\n  };\n  var microsoft = {\n    mouseup: 'MSPointerUp',\n    mousedown: 'MSPointerDown',\n    mousemove: 'MSPointerMove'\n  };\n  if (global.navigator.pointerEnabled) {\n    crossvent[op](el, pointers[type], fn);\n  } else if (global.navigator.msPointerEnabled) {\n    crossvent[op](el, microsoft[type], fn);\n  } else {\n    crossvent[op](el, touch[type], fn);\n    crossvent[op](el, type, fn);\n  }\n}\n\nfunction whichMouseButton (e) {\n  if (e.touches !== void 0) { return e.touches.length; }\n  if (e.which !== void 0 && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== void 0) { return e.buttons; }\n  var button = e.button;\n  if (button !== void 0) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n\nfunction getOffset (el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset')\n  };\n}\n\nfunction getScroll (scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getElementBehindPoint (point, x, y) {\n  var p = point || {};\n  var state = p.className;\n  var el;\n  p.className += ' gu-hide';\n  el = doc.elementFromPoint(x, y);\n  p.className = state;\n  return el;\n}\n\nfunction never () { return false; }\nfunction always () { return true; }\nfunction getRectWidth (rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight (rect) { return rect.height || (rect.bottom - rect.top); }\nfunction getParent (el) { return el.parentNode === doc ? null : el.parentNode; }\nfunction isInput (el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\nfunction isEditable (el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\nfunction nextEl (el) {\n  return el.nextElementSibling || manually();\n  function manually () {\n    var sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n}\n\nfunction getEventHost (e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\nfunction getCoord (coord, e) {\n  var host = getEventHost(e);\n  var missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY' // IE8\n  };\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coord = missMap[coord];\n  }\n  return host[coord];\n}\n\nmodule.exports = dragula;\n"]},"metadata":{},"sourceType":"script"}