{"ast":null,"code":"import _toConsumableArray from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _createClass from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _slicedToArray from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"C:\\\\dev\\\\saltiest\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport * as dragulaExpt from 'dragula';\nimport dragulaExpt__default from 'dragula';\nimport { Injectable, Optional, Directive, Input, Output, ElementRef, EventEmitter, NgModule } from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar Group =\n/**\n * @param {?} name\n * @param {?} drake\n * @param {?} options\n */\nfunction Group(name, drake, options) {\n  _classCallCheck(this, Group);\n\n  this.name = name;\n  this.drake = drake;\n  this.options = options;\n  this.initEvents = false;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @enum {string} */\n\n\nvar EventTypes = {\n  Cancel: \"cancel\",\n  Cloned: \"cloned\",\n  Drag: \"drag\",\n  DragEnd: \"dragend\",\n  Drop: \"drop\",\n  Out: \"out\",\n  Over: \"over\",\n  Remove: \"remove\",\n  Shadow: \"shadow\",\n  DropModel: \"dropModel\",\n  RemoveModel: \"removeModel\"\n};\n/** @type {?} */\n\nvar AllEvents = Object.keys(EventTypes).map(function (k) {\n  return (\n    /** @type {?} */\n    EventTypes[\n    /** @type {?} */\n    k]\n  );\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @type {?} */\n\nvar dragula = dragulaExpt__default || dragulaExpt;\n\nvar DrakeFactory =\n/**\n * @param {?=} build\n */\nfunction DrakeFactory() {\n  var build = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : dragula;\n\n  _classCallCheck(this, DrakeFactory);\n\n  this.build = build;\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar filterEvent = function filterEvent(eventType, filterDragType, projector) {\n  return function (input) {\n    return input.pipe(filter(function (_ref) {\n      var event = _ref.event,\n          name = _ref.name;\n      return event === eventType && (filterDragType === undefined || name === filterDragType);\n    }), map(function (_ref2) {\n      var name = _ref2.name,\n          args = _ref2.args;\n      return projector(name, args);\n    }));\n  };\n};\n/** @type {?} */\n\n\nvar elContainerSourceProjector = function elContainerSourceProjector(name, _ref3) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n      el = _ref4[0],\n      container = _ref4[1],\n      source = _ref4[2];\n\n  return {\n    name: name,\n    el: el,\n    container: container,\n    source: source\n  };\n};\n\nvar DragulaService = /*#__PURE__*/function () {\n  /**\n   * @param {?=} drakeFactory\n   */\n  function DragulaService() {\n    var _this = this;\n\n    var drakeFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, DragulaService);\n\n    this.drakeFactory = drakeFactory;\n    this.dispatch$ = new Subject();\n\n    this.drag = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.Drag, groupName, function (name, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            el = _ref6[0],\n            source = _ref6[1];\n\n        return {\n          name: name,\n          el: el,\n          source: source\n        };\n      }));\n    };\n\n    this.dragend = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.DragEnd, groupName, function (name, _ref7) {\n        var _ref8 = _slicedToArray(_ref7, 1),\n            el = _ref8[0];\n\n        return {\n          name: name,\n          el: el\n        };\n      }));\n    };\n\n    this.drop = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.Drop, groupName, function (name, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 4),\n            el = _ref10[0],\n            target = _ref10[1],\n            source = _ref10[2],\n            sibling = _ref10[3];\n\n        return {\n          name: name,\n          el: el,\n          target: target,\n          source: source,\n          sibling: sibling\n        };\n      }));\n    };\n\n    this.elContainerSource = function (eventType) {\n      return function (groupName) {\n        return _this.dispatch$.pipe(filterEvent(eventType, groupName, elContainerSourceProjector));\n      };\n    };\n\n    this.cancel = this.elContainerSource(EventTypes.Cancel);\n    this.remove = this.elContainerSource(EventTypes.Remove);\n    this.shadow = this.elContainerSource(EventTypes.Shadow);\n    this.over = this.elContainerSource(EventTypes.Over);\n    this.out = this.elContainerSource(EventTypes.Out);\n\n    this.cloned = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.Cloned, groupName, function (name, _ref11) {\n        var _ref12 = _slicedToArray(_ref11, 3),\n            clone = _ref12[0],\n            original = _ref12[1],\n            cloneType = _ref12[2];\n\n        return {\n          name: name,\n          clone: clone,\n          original: original,\n          cloneType: cloneType\n        };\n      }));\n    };\n\n    this.dropModel = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.DropModel, groupName, function (name, _ref13) {\n        var _ref14 = _slicedToArray(_ref13, 9),\n            el = _ref14[0],\n            target = _ref14[1],\n            source = _ref14[2],\n            sibling = _ref14[3],\n            item = _ref14[4],\n            sourceModel = _ref14[5],\n            targetModel = _ref14[6],\n            sourceIndex = _ref14[7],\n            targetIndex = _ref14[8];\n\n        return {\n          name: name,\n          el: el,\n          target: target,\n          source: source,\n          sibling: sibling,\n          item: item,\n          sourceModel: sourceModel,\n          targetModel: targetModel,\n          sourceIndex: sourceIndex,\n          targetIndex: targetIndex\n        };\n      }));\n    };\n\n    this.removeModel = function (groupName) {\n      return _this.dispatch$.pipe(filterEvent(EventTypes.RemoveModel, groupName, function (name, _ref15) {\n        var _ref16 = _slicedToArray(_ref15, 6),\n            el = _ref16[0],\n            container = _ref16[1],\n            source = _ref16[2],\n            item = _ref16[3],\n            sourceModel = _ref16[4],\n            sourceIndex = _ref16[5];\n\n        return {\n          name: name,\n          el: el,\n          container: container,\n          source: source,\n          item: item,\n          sourceModel: sourceModel,\n          sourceIndex: sourceIndex\n        };\n      }));\n    };\n\n    this.groups = {};\n\n    if (this.drakeFactory === null) {\n      this.drakeFactory = new DrakeFactory();\n    }\n  }\n  /**\n   * Public mainly for testing purposes. Prefer `createGroup()`.\n   * @param {?} group\n   * @return {?}\n   */\n\n\n  _createClass(DragulaService, [{\n    key: \"add\",\n    value: function add(group) {\n      /** @type {?} */\n      var existingGroup = this.find(group.name);\n\n      if (existingGroup) {\n        throw new Error('Group named: \"' + group.name + '\" already exists.');\n      }\n\n      this.groups[group.name] = group;\n      this.handleModels(group);\n      this.setupEvents(group);\n      return group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(name) {\n      return this.groups[name];\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(name) {\n      /** @type {?} */\n      var group = this.find(name);\n\n      if (!group) {\n        return;\n      }\n\n      group.drake && group.drake.destroy();\n      delete this.groups[name];\n    }\n    /**\n     * Creates a group with the specified name and options.\n     *\n     * Note: formerly known as `setOptions`\n     * @template T\n     * @param {?} name\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"createGroup\",\n    value: function createGroup(name, options) {\n      return this.add(new Group(name, this.drakeFactory.build([], options), options));\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n\n  }, {\n    key: \"handleModels\",\n    value: function handleModels(_ref17) {\n      var _this2 = this;\n\n      var name = _ref17.name,\n          drake = _ref17.drake,\n          options = _ref17.options;\n\n      /** @type {?} */\n      var dragElm;\n      /** @type {?} */\n\n      var dragIndex;\n      /** @type {?} */\n\n      var dropIndex;\n      drake.on('remove', function (el, container, source) {\n        if (!drake.models) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var sourceModel = drake.models[drake.containers.indexOf(source)];\n        sourceModel = sourceModel.slice(0);\n        /** @type {?} */\n\n        var item = sourceModel.splice(dragIndex, 1)[0]; // console.log('REMOVE');\n        // console.log(sourceModel);\n\n        _this2.dispatch$.next({\n          event: EventTypes.RemoveModel,\n          name: name,\n          args: [el, container, source, item, sourceModel, dragIndex]\n        });\n      });\n      drake.on('drag', function (el, source) {\n        if (!drake.models) {\n          return;\n        }\n\n        dragElm = el;\n        dragIndex = _this2.domIndexOf(el, source);\n      });\n      drake.on('drop', function (dropElm, target, source, sibling) {\n        if (!drake.models || !target) {\n          return;\n        }\n\n        dropIndex = _this2.domIndexOf(dropElm, target);\n        /** @type {?} */\n\n        var sourceModel = drake.models[drake.containers.indexOf(source)];\n        /** @type {?} */\n\n        var targetModel = drake.models[drake.containers.indexOf(target)];\n        /** @type {?} */\n\n        var item;\n\n        if (target === source) {\n          sourceModel = sourceModel.slice(0);\n          item = sourceModel.splice(dragIndex, 1)[0];\n          sourceModel.splice(dropIndex, 0, item); // this was true before we cloned and updated sourceModel,\n          // but targetModel still has the old value\n\n          targetModel = sourceModel;\n        } else {\n          /** @type {?} */\n          var isCopying = dragElm !== dropElm;\n          item = sourceModel[dragIndex];\n\n          if (isCopying) {\n            if (!options.copyItem) {\n              throw new Error(\"If you have enabled `copy` on a group, you must provide a `copyItem` function.\");\n            }\n\n            item = options.copyItem(item);\n          }\n\n          if (!isCopying) {\n            sourceModel = sourceModel.slice(0);\n            sourceModel.splice(dragIndex, 1);\n          }\n\n          targetModel = targetModel.slice(0);\n          targetModel.splice(dropIndex, 0, item);\n\n          if (isCopying) {\n            try {\n              target.removeChild(dropElm);\n            } catch (e) {}\n          }\n        }\n\n        _this2.dispatch$.next({\n          event: EventTypes.DropModel,\n          name: name,\n          args: [dropElm, target, source, sibling, item, sourceModel, targetModel, dragIndex, dropIndex]\n        });\n      });\n    }\n    /**\n     * @param {?} group\n     * @return {?}\n     */\n\n  }, {\n    key: \"setupEvents\",\n    value: function setupEvents(group) {\n      var _this3 = this;\n\n      if (group.initEvents) {\n        return;\n      }\n\n      group.initEvents = true;\n      /** @type {?} */\n\n      var name = group.name;\n      /** @type {?} */\n\n      var emitter = function emitter(event) {\n        group.drake.on(event, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this3.dispatch$.next({\n            event: event,\n            name: name,\n            args: args\n          });\n        });\n      };\n\n      AllEvents.forEach(emitter);\n    }\n    /**\n     * @param {?} child\n     * @param {?} parent\n     * @return {?}\n     */\n\n  }, {\n    key: \"domIndexOf\",\n    value: function domIndexOf(child, parent) {\n      return Array.prototype.indexOf.call(parent.children, child);\n    }\n  }]);\n\n  return DragulaService;\n}();\n\nDragulaService.ɵfac = function DragulaService_Factory(t) {\n  return new (t || DragulaService)(ɵngcc0.ɵɵinject(DrakeFactory, 8));\n};\n\nDragulaService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DragulaService,\n  factory: DragulaService.ɵfac\n});\n/** @nocollapse */\n\nDragulaService.ctorParameters = function () {\n  return [{\n    type: DrakeFactory,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DrakeFactory,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar DragulaDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} el\n   * @param {?} dragulaService\n   */\n  function DragulaDirective(el, dragulaService) {\n    _classCallCheck(this, DragulaDirective);\n\n    this.el = el;\n    this.dragulaService = dragulaService;\n    this.dragulaModelChange = new EventEmitter();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DragulaDirective, [{\n    key: \"container\",\n    get: function get() {\n      return this.el && this.el.nativeElement;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes && changes.dragula) {\n        var _changes$dragula = changes.dragula,\n            prev = _changes$dragula.previousValue,\n            current = _changes$dragula.currentValue,\n            firstChange = _changes$dragula.firstChange;\n        /** @type {?} */\n\n        var hadPreviousValue = !!prev;\n        /** @type {?} */\n\n        var hasNewValue = !!current; // something -> null       =>  teardown only\n        // something -> something  =>  teardown, then setup\n        //      null -> something  =>  setup only\n        //\n        //      null -> null (precluded by fact of change being present)\n\n        if (hadPreviousValue) {\n          this.teardown(prev);\n        }\n\n        if (hasNewValue) {\n          this.setup();\n        }\n      } else if (changes && changes.dragulaModel) {\n        var _changes$dragulaModel = changes.dragulaModel,\n            _prev = _changes$dragulaModel.previousValue,\n            _current = _changes$dragulaModel.currentValue,\n            _firstChange = _changes$dragulaModel.firstChange;\n        var drake = this.group.drake;\n\n        if (this.dragula && drake) {\n          drake.models = drake.models || [];\n          /** @type {?} */\n\n          var prevIndex = drake.models.indexOf(_prev);\n\n          if (prevIndex !== -1) {\n            // delete the previous\n            drake.models.splice(prevIndex, 1); // maybe insert a new one at the same spot\n\n            if (!!_current) {\n              drake.models.splice(prevIndex, 0, _current);\n            }\n          } else if (!!_current) {\n            // no previous one to remove; just push this one.\n            drake.models.push(_current);\n          }\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this4 = this;\n\n      /** @type {?} */\n      var checkModel = function checkModel(group) {\n        if (_this4.dragulaModel) {\n          if (group.drake.models) {\n            group.drake.models.push(_this4.dragulaModel);\n          } else {\n            group.drake.models = [_this4.dragulaModel];\n          }\n        }\n      };\n      /** @type {?} */\n\n\n      var group = this.dragulaService.find(this.dragula);\n\n      if (!group) {\n        /** @type {?} */\n        var options = {};\n        group = this.dragulaService.createGroup(this.dragula, options);\n      } // ensure model and container element are pushed\n\n\n      checkModel(group);\n      group.drake.containers.push(this.container);\n      this.subscribe(this.dragula);\n      this.group = group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(name) {\n      var _this5 = this;\n\n      this.subs = new Subscription();\n      this.subs.add(this.dragulaService.dropModel(name).subscribe(function (_ref18) {\n        var source = _ref18.source,\n            target = _ref18.target,\n            sourceModel = _ref18.sourceModel,\n            targetModel = _ref18.targetModel;\n\n        if (source === _this5.el.nativeElement) {\n          _this5.dragulaModelChange.emit(sourceModel);\n        } else if (target === _this5.el.nativeElement) {\n          _this5.dragulaModelChange.emit(targetModel);\n        }\n      }));\n      this.subs.add(this.dragulaService.removeModel(name).subscribe(function (_ref19) {\n        var source = _ref19.source,\n            sourceModel = _ref19.sourceModel;\n\n        if (source === _this5.el.nativeElement) {\n          _this5.dragulaModelChange.emit(sourceModel);\n        }\n      }));\n    }\n    /**\n     * @param {?} groupName\n     * @return {?}\n     */\n\n  }, {\n    key: \"teardown\",\n    value: function teardown(groupName) {\n      if (this.subs) {\n        this.subs.unsubscribe();\n      }\n      /** @type {?} */\n\n\n      var group = this.dragulaService.find(groupName);\n\n      if (group) {\n        /** @type {?} */\n        var itemToRemove = group.drake.containers.indexOf(this.el.nativeElement);\n\n        if (itemToRemove !== -1) {\n          group.drake.containers.splice(itemToRemove, 1);\n        }\n\n        if (this.dragulaModel && group.drake && group.drake.models) {\n          /** @type {?} */\n          var modelIndex = group.drake.models.indexOf(this.dragulaModel);\n\n          if (modelIndex !== -1) {\n            group.drake.models.splice(modelIndex, 1);\n          }\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.teardown(this.dragula);\n    }\n  }]);\n\n  return DragulaDirective;\n}();\n\nDragulaDirective.ɵfac = function DragulaDirective_Factory(t) {\n  return new (t || DragulaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragulaService));\n};\n\nDragulaDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DragulaDirective,\n  selectors: [[\"\", \"dragula\", \"\"]],\n  inputs: {\n    dragula: \"dragula\",\n    dragulaModel: \"dragulaModel\"\n  },\n  outputs: {\n    dragulaModelChange: \"dragulaModelChange\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDragulaDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: DragulaService\n  }];\n};\n\nDragulaDirective.propDecorators = {\n  dragula: [{\n    type: Input\n  }],\n  dragulaModel: [{\n    type: Input\n  }],\n  dragulaModelChange: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[dragula]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DragulaService\n    }];\n  }, {\n    dragulaModelChange: [{\n      type: Output\n    }],\n    dragula: [{\n      type: Input\n    }],\n    dragulaModel: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar DragulaModule = /*#__PURE__*/function () {\n  function DragulaModule() {\n    _classCallCheck(this, DragulaModule);\n  }\n\n  _createClass(DragulaModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * @return {?}\n     */\n    function forRoot() {\n      return {\n        ngModule: DragulaModule,\n        providers: [DragulaService]\n      };\n    }\n  }]);\n\n  return DragulaModule;\n}();\n\nDragulaModule.ɵfac = function DragulaModule_Factory(t) {\n  return new (t || DragulaModule)();\n};\n\nDragulaModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: DragulaModule\n});\nDragulaModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaModule, [{\n    type: NgModule,\n    args: [{\n      exports: [DragulaDirective],\n      declarations: [DragulaDirective]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragulaModule, {\n    declarations: [DragulaDirective],\n    exports: [DragulaDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar MockDrakeFactory = new DrakeFactory(function (containers, options) {\n  return new MockDrake(containers, options);\n});\n/**\n * You can use MockDrake to simulate Drake events.\n *\n * The three methods that actually do anything are `on(event, listener)`,\n * `destroy()`, and a new method, `emit()`. Use `emit()` to manually emit Drake\n * events, and if you injected MockDrake properly with MockDrakeFactory or\n * mocked the DragulaService.find() method, then you can make ng2-dragula think\n * drags and drops are happening.\n *\n * Caveats:\n *\n * 1. YOU MUST MAKE THE DOM CHANGES YOURSELF.\n * 2. REPEAT: YOU MUST MAKE THE DOM CHANGES YOURSELF.\n *    That means `source.removeChild(el)`, and `target.insertBefore(el)`.\n * 3. None of the other methods do anything.\n *    That's ok, because ng2-dragula doesn't use them.\n */\n\nvar MockDrake = /*#__PURE__*/function () {\n  /**\n   * @param {?=} containers A list of container elements.\n   * @param {?=} options These will NOT be used. At all.\n   * @param {?=} models Nonstandard, but useful for testing using `new MockDrake()` directly.\n   *               Note, default value is undefined, like a real Drake. Don't change that.\n   */\n  function MockDrake() {\n    var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var models = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, MockDrake);\n\n    this.containers = containers;\n    this.options = options;\n    this.models = models;\n    /* Doesn't represent anything meaningful. */\n\n    this.dragging = false;\n    this.emitter$ = new Subject();\n    this.subs = new Subscription();\n  }\n  /**\n   * @param {?} item\n   * @return {?}\n   */\n\n\n  _createClass(MockDrake, [{\n    key: \"start\",\n    value: function start(item) {\n      this.dragging = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.dragging = false;\n    }\n    /**\n     * @param {?=} revert\n     * @return {?}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(revert) {\n      this.dragging = false;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.dragging = false;\n    }\n    /**\n     * @param {?} event\n     * @param {?} callback\n     * @return {?}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.subs.add(this.emitter$.pipe(filter(function (_ref20) {\n        var eventType = _ref20.eventType;\n        return eventType === event;\n      })).subscribe(function (_ref21) {\n        var args = _ref21.args;\n        callback.apply(void 0, _toConsumableArray(args));\n      }));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.subs.unsubscribe();\n    }\n    /**\n     * This is the most useful method. You can use it to manually fire events that would normally\n     * be fired by a real drake.\n     *\n     * You're likely most interested in firing `drag`, `remove` and `drop`, the three events\n     * DragulaService uses to implement [dragulaModel].\n     *\n     * See https://github.com/bevacqua/dragula#drakeon-events for what you should emit (and in what order).\n     *\n     * (Note also, firing dropModel and removeModel won't work. You would have to mock DragulaService for that.)\n     * @param {?} eventType\n     * @param {...?} args\n     * @return {?}\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(eventType) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this.emitter$.next({\n        eventType: eventType,\n        args: args\n      });\n    }\n  }]);\n\n  return MockDrake;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nexport { DragulaDirective, DragulaService, DragulaModule, dragula, DrakeFactory, Group, EventTypes, MockDrake, MockDrakeFactory };","map":{"version":3,"sources":["C:/dev/saltiest/node_modules/ng2-dragula/__ivy_ngcc__/dist/fesm2015/ng2-dragula.js"],"names":["dragulaExpt","dragulaExpt__default","Injectable","Optional","Directive","Input","Output","ElementRef","EventEmitter","NgModule","Subject","Subscription","filter","map","ɵngcc0","Group","name","drake","options","initEvents","EventTypes","Cancel","Cloned","Drag","DragEnd","Drop","Out","Over","Remove","Shadow","DropModel","RemoveModel","AllEvents","Object","keys","k","dragula","DrakeFactory","build","filterEvent","eventType","filterDragType","projector","input","pipe","event","undefined","args","elContainerSourceProjector","el","container","source","DragulaService","drakeFactory","dispatch$","drag","groupName","dragend","drop","target","sibling","elContainerSource","cancel","remove","shadow","over","out","cloned","clone","original","cloneType","dropModel","item","sourceModel","targetModel","sourceIndex","targetIndex","removeModel","groups","group","existingGroup","find","Error","handleModels","setupEvents","destroy","add","dragElm","dragIndex","dropIndex","on","models","containers","indexOf","slice","splice","next","domIndexOf","dropElm","isCopying","copyItem","removeChild","e","emitter","forEach","child","parent","Array","prototype","call","children","ɵfac","DragulaService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ctorParameters","type","decorators","ngDevMode","ɵsetClassMetadata","DragulaDirective","dragulaService","dragulaModelChange","nativeElement","changes","prev","previousValue","current","currentValue","firstChange","hadPreviousValue","hasNewValue","teardown","setup","dragulaModel","prevIndex","push","checkModel","createGroup","subscribe","subs","emit","unsubscribe","itemToRemove","modelIndex","DragulaDirective_Factory","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","selectors","inputs","outputs","features","ɵɵNgOnChangesFeature","propDecorators","selector","DragulaModule","ngModule","providers","DragulaModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","exports","declarations","ngJitMode","ɵɵsetNgModuleScope","MockDrakeFactory","MockDrake","dragging","emitter$","revert","callback"],"mappings":"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","sourcesContent":["import * as dragulaExpt from 'dragula';\nimport dragulaExpt__default, {  } from 'dragula';\nimport { Injectable, Optional, Directive, Input, Output, ElementRef, EventEmitter, NgModule } from '@angular/core';\nimport { Subject, Subscription } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nclass Group {\n    /**\n     * @param {?} name\n     * @param {?} drake\n     * @param {?} options\n     */\n    constructor(name, drake, options) {\n        this.name = name;\n        this.drake = drake;\n        this.options = options;\n        this.initEvents = false;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {string} */\nconst EventTypes = {\n    Cancel: \"cancel\",\n    Cloned: \"cloned\",\n    Drag: \"drag\",\n    DragEnd: \"dragend\",\n    Drop: \"drop\",\n    Out: \"out\",\n    Over: \"over\",\n    Remove: \"remove\",\n    Shadow: \"shadow\",\n    DropModel: \"dropModel\",\n    RemoveModel: \"removeModel\",\n};\n/** @type {?} */\nconst AllEvents = Object.keys(EventTypes).map(k => /** @type {?} */ (EventTypes[/** @type {?} */ (k)]));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst dragula = dragulaExpt__default || dragulaExpt;\nclass DrakeFactory {\n    /**\n     * @param {?=} build\n     */\n    constructor(build = dragula) {\n        this.build = build;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst filterEvent = (eventType, filterDragType, projector) => (input) => {\n    return input.pipe(filter(({ event, name }) => {\n        return event === eventType\n            && (filterDragType === undefined || name === filterDragType);\n    }), map(({ name, args }) => projector(name, args)));\n};\n/** @type {?} */\nconst elContainerSourceProjector = (name, [el, container, source]) => ({ name, el, container, source });\nclass DragulaService {\n    /**\n     * @param {?=} drakeFactory\n     */\n    constructor(drakeFactory = null) {\n        this.drakeFactory = drakeFactory;\n        this.dispatch$ = new Subject();\n        this.drag = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Drag, groupName, (name, [el, source]) => ({ name, el, source })));\n        this.dragend = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.DragEnd, groupName, (name, [el]) => ({ name, el })));\n        this.drop = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Drop, groupName, (name, [el, target, source, sibling]) => {\n            return { name, el, target, source, sibling };\n        }));\n        this.elContainerSource = (eventType) => (groupName) => this.dispatch$.pipe(filterEvent(eventType, groupName, elContainerSourceProjector));\n        this.cancel = this.elContainerSource(EventTypes.Cancel);\n        this.remove = this.elContainerSource(EventTypes.Remove);\n        this.shadow = this.elContainerSource(EventTypes.Shadow);\n        this.over = this.elContainerSource(EventTypes.Over);\n        this.out = this.elContainerSource(EventTypes.Out);\n        this.cloned = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.Cloned, groupName, (name, [clone, original, cloneType]) => {\n            return { name, clone, original, cloneType };\n        }));\n        this.dropModel = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.DropModel, groupName, (name, [el, target, source, sibling, item, sourceModel, targetModel, sourceIndex, targetIndex]) => {\n            return { name, el, target, source, sibling, item, sourceModel, targetModel, sourceIndex, targetIndex };\n        }));\n        this.removeModel = (groupName) => this.dispatch$.pipe(filterEvent(EventTypes.RemoveModel, groupName, (name, [el, container, source, item, sourceModel, sourceIndex]) => {\n            return { name, el, container, source, item, sourceModel, sourceIndex };\n        }));\n        this.groups = {};\n        if (this.drakeFactory === null) {\n            this.drakeFactory = new DrakeFactory();\n        }\n    }\n    /**\n     * Public mainly for testing purposes. Prefer `createGroup()`.\n     * @param {?} group\n     * @return {?}\n     */\n    add(group) {\n        /** @type {?} */\n        let existingGroup = this.find(group.name);\n        if (existingGroup) {\n            throw new Error('Group named: \"' + group.name + '\" already exists.');\n        }\n        this.groups[group.name] = group;\n        this.handleModels(group);\n        this.setupEvents(group);\n        return group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    find(name) {\n        return this.groups[name];\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    destroy(name) {\n        /** @type {?} */\n        let group = this.find(name);\n        if (!group) {\n            return;\n        }\n        group.drake && group.drake.destroy();\n        delete this.groups[name];\n    }\n    /**\n     * Creates a group with the specified name and options.\n     *\n     * Note: formerly known as `setOptions`\n     * @template T\n     * @param {?} name\n     * @param {?} options\n     * @return {?}\n     */\n    createGroup(name, options) {\n        return this.add(new Group(name, this.drakeFactory.build([], options), options));\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleModels({ name, drake, options }) {\n        /** @type {?} */\n        let dragElm;\n        /** @type {?} */\n        let dragIndex;\n        /** @type {?} */\n        let dropIndex;\n        drake.on('remove', (el, container, source) => {\n            if (!drake.models) {\n                return;\n            }\n            /** @type {?} */\n            let sourceModel = drake.models[drake.containers.indexOf(source)];\n            sourceModel = sourceModel.slice(0);\n            /** @type {?} */\n            const item = sourceModel.splice(dragIndex, 1)[0];\n            // console.log('REMOVE');\n            // console.log(sourceModel);\n            this.dispatch$.next({\n                event: EventTypes.RemoveModel,\n                name,\n                args: [el, container, source, item, sourceModel, dragIndex]\n            });\n        });\n        drake.on('drag', (el, source) => {\n            if (!drake.models) {\n                return;\n            }\n            dragElm = el;\n            dragIndex = this.domIndexOf(el, source);\n        });\n        drake.on('drop', (dropElm, target, source, sibling) => {\n            if (!drake.models || !target) {\n                return;\n            }\n            dropIndex = this.domIndexOf(dropElm, target);\n            /** @type {?} */\n            let sourceModel = drake.models[drake.containers.indexOf(source)];\n            /** @type {?} */\n            let targetModel = drake.models[drake.containers.indexOf(target)];\n            /** @type {?} */\n            let item;\n            if (target === source) {\n                sourceModel = sourceModel.slice(0);\n                item = sourceModel.splice(dragIndex, 1)[0];\n                sourceModel.splice(dropIndex, 0, item);\n                // this was true before we cloned and updated sourceModel,\n                // but targetModel still has the old value\n                targetModel = sourceModel;\n            }\n            else {\n                /** @type {?} */\n                let isCopying = dragElm !== dropElm;\n                item = sourceModel[dragIndex];\n                if (isCopying) {\n                    if (!options.copyItem) {\n                        throw new Error(\"If you have enabled `copy` on a group, you must provide a `copyItem` function.\");\n                    }\n                    item = options.copyItem(item);\n                }\n                if (!isCopying) {\n                    sourceModel = sourceModel.slice(0);\n                    sourceModel.splice(dragIndex, 1);\n                }\n                targetModel = targetModel.slice(0);\n                targetModel.splice(dropIndex, 0, item);\n                if (isCopying) {\n                    try {\n                        target.removeChild(dropElm);\n                    }\n                    catch (e) { }\n                }\n            }\n            this.dispatch$.next({\n                event: EventTypes.DropModel,\n                name,\n                args: [dropElm, target, source, sibling, item, sourceModel, targetModel, dragIndex, dropIndex]\n            });\n        });\n    }\n    /**\n     * @param {?} group\n     * @return {?}\n     */\n    setupEvents(group) {\n        if (group.initEvents) {\n            return;\n        }\n        group.initEvents = true;\n        /** @type {?} */\n        const name = group.name;\n        /** @type {?} */\n        let emitter = (event) => {\n            group.drake.on(event, (...args) => {\n                this.dispatch$.next({ event, name, args });\n            });\n        };\n        AllEvents.forEach(emitter);\n    }\n    /**\n     * @param {?} child\n     * @param {?} parent\n     * @return {?}\n     */\n    domIndexOf(child, parent) {\n        return Array.prototype.indexOf.call(parent.children, child);\n    }\n}\nDragulaService.ɵfac = function DragulaService_Factory(t) { return new (t || DragulaService)(ɵngcc0.ɵɵinject(DrakeFactory, 8)); };\nDragulaService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DragulaService, factory: DragulaService.ɵfac });\n/** @nocollapse */\nDragulaService.ctorParameters = () => [\n    { type: DrakeFactory, decorators: [{ type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaService, [{\n        type: Injectable\n    }], function () { return [{ type: DrakeFactory, decorators: [{\n                type: Optional\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaDirective {\n    /**\n     * @param {?} el\n     * @param {?} dragulaService\n     */\n    constructor(el, dragulaService) {\n        this.el = el;\n        this.dragulaService = dragulaService;\n        this.dragulaModelChange = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    get container() {\n        return this.el && this.el.nativeElement;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes && changes.dragula) {\n            const { previousValue: prev, currentValue: current, firstChange } = changes.dragula;\n            /** @type {?} */\n            let hadPreviousValue = !!prev;\n            /** @type {?} */\n            let hasNewValue = !!current;\n            // something -> null       =>  teardown only\n            // something -> something  =>  teardown, then setup\n            //      null -> something  =>  setup only\n            //\n            //      null -> null (precluded by fact of change being present)\n            if (hadPreviousValue) {\n                this.teardown(prev);\n            }\n            if (hasNewValue) {\n                this.setup();\n            }\n        }\n        else if (changes && changes.dragulaModel) {\n            const { previousValue: prev, currentValue: current, firstChange } = changes.dragulaModel;\n            const { drake } = this.group;\n            if (this.dragula && drake) {\n                drake.models = drake.models || [];\n                /** @type {?} */\n                let prevIndex = drake.models.indexOf(prev);\n                if (prevIndex !== -1) {\n                    // delete the previous\n                    drake.models.splice(prevIndex, 1);\n                    // maybe insert a new one at the same spot\n                    if (!!current) {\n                        drake.models.splice(prevIndex, 0, current);\n                    }\n                }\n                else if (!!current) {\n                    // no previous one to remove; just push this one.\n                    drake.models.push(current);\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        /** @type {?} */\n        let checkModel = (group) => {\n            if (this.dragulaModel) {\n                if (group.drake.models) {\n                    group.drake.models.push(this.dragulaModel);\n                }\n                else {\n                    group.drake.models = [this.dragulaModel];\n                }\n            }\n        };\n        /** @type {?} */\n        let group = this.dragulaService.find(this.dragula);\n        if (!group) {\n            /** @type {?} */\n            let options = {};\n            group = this.dragulaService.createGroup(this.dragula, options);\n        }\n        // ensure model and container element are pushed\n        checkModel(group);\n        group.drake.containers.push(this.container);\n        this.subscribe(this.dragula);\n        this.group = group;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    subscribe(name) {\n        this.subs = new Subscription();\n        this.subs.add(this.dragulaService\n            .dropModel(name)\n            .subscribe(({ source, target, sourceModel, targetModel }) => {\n            if (source === this.el.nativeElement) {\n                this.dragulaModelChange.emit(sourceModel);\n            }\n            else if (target === this.el.nativeElement) {\n                this.dragulaModelChange.emit(targetModel);\n            }\n        }));\n        this.subs.add(this.dragulaService\n            .removeModel(name)\n            .subscribe(({ source, sourceModel }) => {\n            if (source === this.el.nativeElement) {\n                this.dragulaModelChange.emit(sourceModel);\n            }\n        }));\n    }\n    /**\n     * @param {?} groupName\n     * @return {?}\n     */\n    teardown(groupName) {\n        if (this.subs) {\n            this.subs.unsubscribe();\n        }\n        /** @type {?} */\n        const group = this.dragulaService.find(groupName);\n        if (group) {\n            /** @type {?} */\n            const itemToRemove = group.drake.containers.indexOf(this.el.nativeElement);\n            if (itemToRemove !== -1) {\n                group.drake.containers.splice(itemToRemove, 1);\n            }\n            if (this.dragulaModel && group.drake && group.drake.models) {\n                /** @type {?} */\n                let modelIndex = group.drake.models.indexOf(this.dragulaModel);\n                if (modelIndex !== -1) {\n                    group.drake.models.splice(modelIndex, 1);\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.teardown(this.dragula);\n    }\n}\nDragulaDirective.ɵfac = function DragulaDirective_Factory(t) { return new (t || DragulaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragulaService)); };\nDragulaDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DragulaDirective, selectors: [[\"\", \"dragula\", \"\"]], inputs: { dragula: \"dragula\", dragulaModel: \"dragulaModel\" }, outputs: { dragulaModelChange: \"dragulaModelChange\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nDragulaDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragulaService }\n];\nDragulaDirective.propDecorators = {\n    dragula: [{ type: Input }],\n    dragulaModel: [{ type: Input }],\n    dragulaModelChange: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaDirective, [{\n        type: Directive,\n        args: [{ selector: '[dragula]' }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DragulaService }]; }, { dragulaModelChange: [{\n            type: Output\n        }], dragula: [{\n            type: Input\n        }], dragulaModel: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass DragulaModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return {\n            ngModule: DragulaModule,\n            providers: [DragulaService]\n        };\n    }\n}\nDragulaModule.ɵfac = function DragulaModule_Factory(t) { return new (t || DragulaModule)(); };\nDragulaModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DragulaModule });\nDragulaModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragulaModule, [{\n        type: NgModule,\n        args: [{\n                exports: [DragulaDirective],\n                declarations: [DragulaDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragulaModule, { declarations: [DragulaDirective], exports: [DragulaDirective] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @type {?} */\nconst MockDrakeFactory = new DrakeFactory((containers, options) => {\n    return new MockDrake(containers, options);\n});\n/**\n * You can use MockDrake to simulate Drake events.\n *\n * The three methods that actually do anything are `on(event, listener)`,\n * `destroy()`, and a new method, `emit()`. Use `emit()` to manually emit Drake\n * events, and if you injected MockDrake properly with MockDrakeFactory or\n * mocked the DragulaService.find() method, then you can make ng2-dragula think\n * drags and drops are happening.\n *\n * Caveats:\n *\n * 1. YOU MUST MAKE THE DOM CHANGES YOURSELF.\n * 2. REPEAT: YOU MUST MAKE THE DOM CHANGES YOURSELF.\n *    That means `source.removeChild(el)`, and `target.insertBefore(el)`.\n * 3. None of the other methods do anything.\n *    That's ok, because ng2-dragula doesn't use them.\n */\nclass MockDrake {\n    /**\n     * @param {?=} containers A list of container elements.\n     * @param {?=} options These will NOT be used. At all.\n     * @param {?=} models Nonstandard, but useful for testing using `new MockDrake()` directly.\n     *               Note, default value is undefined, like a real Drake. Don't change that.\n     */\n    constructor(containers = [], options = {}, models) {\n        this.containers = containers;\n        this.options = options;\n        this.models = models;\n        /* Doesn't represent anything meaningful. */\n        this.dragging = false;\n        this.emitter$ = new Subject();\n        this.subs = new Subscription();\n    }\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    start(item) {\n        this.dragging = true;\n    }\n    /**\n     * @return {?}\n     */\n    end() {\n        this.dragging = false;\n    }\n    /**\n     * @param {?=} revert\n     * @return {?}\n     */\n    cancel(revert) {\n        this.dragging = false;\n    }\n    /**\n     * @return {?}\n     */\n    remove() {\n        this.dragging = false;\n    }\n    /**\n     * @param {?} event\n     * @param {?} callback\n     * @return {?}\n     */\n    on(event, callback) {\n        this.subs.add(this.emitter$\n            .pipe(filter(({ eventType }) => eventType === event))\n            .subscribe(({ args }) => {\n            callback(...args);\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    destroy() {\n        this.subs.unsubscribe();\n    }\n    /**\n     * This is the most useful method. You can use it to manually fire events that would normally\n     * be fired by a real drake.\n     *\n     * You're likely most interested in firing `drag`, `remove` and `drop`, the three events\n     * DragulaService uses to implement [dragulaModel].\n     *\n     * See https://github.com/bevacqua/dragula#drakeon-events for what you should emit (and in what order).\n     *\n     * (Note also, firing dropModel and removeModel won't work. You would have to mock DragulaService for that.)\n     * @param {?} eventType\n     * @param {...?} args\n     * @return {?}\n     */\n    emit(eventType, ...args) {\n        this.emitter$.next({ eventType, args });\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { DragulaDirective, DragulaService, DragulaModule, dragula, DrakeFactory, Group, EventTypes, MockDrake, MockDrakeFactory };\n\n"]},"metadata":{},"sourceType":"module"}